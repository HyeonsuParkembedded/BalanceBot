#include <unity.h>
#include <stdio.h>
#include <math.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#ifdef NATIVE_BUILD
// Mock ESP32 dependencies for native testing
typedef int esp_err_t;
#define ESP_OK 0
#define ESP_FAIL -1

// Mock ESP32 BT types
typedef enum {
    ESP_BT_MODE_IDLE = 0x00,
    ESP_BT_MODE_BLE = 0x01,
    ESP_BT_MODE_CLASSIC_BT = 0x02,
    ESP_BT_MODE_BTDM = 0x03,
} esp_bt_mode_t;

// Mock logging
#define ESP_LOGE(tag, format, ...) do { (void)tag; } while(0)
#define ESP_LOGW(tag, format, ...) do { (void)tag; } while(0)
#define ESP_LOGI(tag, format, ...) do { (void)tag; } while(0)

// Mock FreeRTOS dependencies
#define portTICK_PERIOD_MS 1
#define pdMS_TO_TICKS(ms) ((ms) / portTICK_PERIOD_MS)
uint32_t xTaskGetTickCount(void) {
    static uint32_t tick = 0;
    return ++tick;
}
void vTaskDelay(const uint32_t xTicksToDelay) {
    (void)xTicksToDelay; // Just ignore the delay in tests
}

// Mock ESP32 error function
const char* esp_err_to_name(esp_err_t code) {
    switch (code) {
        case ESP_OK: return "ESP_OK";
        case ESP_FAIL: return "ESP_FAIL";
        default: return "UNKNOWN_ERROR";
    }
}

// Mock BT functions
esp_err_t esp_bt_controller_mem_release(esp_bt_mode_t mode) { return ESP_OK; }
esp_err_t esp_bt_controller_init(void* cfg) { return ESP_OK; }
esp_err_t esp_bt_controller_enable(esp_bt_mode_t mode) { return ESP_OK; }
esp_err_t esp_bluedroid_init(void) { return ESP_OK; }
esp_err_t esp_bluedroid_enable(void) { return ESP_OK; }

// Mock GAP/GATT functions (empty implementations)
esp_err_t esp_ble_gap_register_callback(void* callback) { return ESP_OK; }
esp_err_t esp_ble_gap_config_adv_data(void* adv_data) { return ESP_OK; }
esp_err_t esp_ble_gap_start_advertising(void* adv_params) { return ESP_OK; }
esp_err_t esp_ble_gap_set_device_name(const char* name) { return ESP_OK; }
esp_err_t esp_ble_gatts_register_callback(void* callback) { return ESP_OK; }
esp_err_t esp_ble_gatts_app_register(uint16_t app_id) { return ESP_OK; }

// Mock BT controller config
typedef struct {
    int dummy;
} esp_bt_controller_config_t;

#define BT_CONTROLLER_INIT_CONFIG_DEFAULT() { .dummy = 0 }

// Mock GPIO types and functions
typedef enum {
    GPIO_NUM_0 = 0,
    GPIO_NUM_1 = 1,
    GPIO_NUM_2 = 2,
    GPIO_NUM_3 = 3,
    GPIO_NUM_4 = 4,
    GPIO_NUM_5 = 5,
    GPIO_NUM_17 = 17,
    GPIO_NUM_18 = 18,
    GPIO_NUM_21 = 21,
    GPIO_NUM_22 = 22,
    GPIO_NUM_MAX = 40
} gpio_num_t;

typedef enum {
    GPIO_MODE_INPUT = 1,
    GPIO_MODE_OUTPUT = 2,
    GPIO_MODE_INPUT_OUTPUT = 3,
} gpio_mode_t;

typedef enum {
    GPIO_PULLUP_DISABLE = 0,
    GPIO_PULLUP_ENABLE = 1,
} gpio_pullup_t;

typedef enum {
    GPIO_PULLDOWN_DISABLE = 0,
    GPIO_PULLDOWN_ENABLE = 1,
} gpio_pulldown_t;

typedef enum {
    GPIO_INTR_DISABLE = 0,
    GPIO_INTR_POSEDGE = 1,
    GPIO_INTR_NEGEDGE = 2,
    GPIO_INTR_ANYEDGE = 3,
} gpio_int_type_t;

typedef struct {
    uint64_t pin_bit_mask;
    gpio_mode_t mode;
    gpio_pullup_t pull_up_en;
    gpio_pulldown_t pull_down_en;
    gpio_int_type_t intr_type;
} gpio_config_t;

// Mock LEDC types
typedef enum {
    LEDC_CHANNEL_0 = 0,
    LEDC_CHANNEL_1 = 1,
    LEDC_CHANNEL_MAX = 8
} ledc_channel_t;

typedef enum {
    LEDC_TIMER_0 = 0,
    LEDC_TIMER_1 = 1,
    LEDC_TIMER_MAX = 4
} ledc_timer_t;

typedef enum {
    LEDC_LOW_SPEED_MODE = 0,
    LEDC_HIGH_SPEED_MODE = 1,
} ledc_mode_t;

typedef enum {
    LEDC_TIMER_8_BIT = 8,
    LEDC_TIMER_10_BIT = 10,
    LEDC_TIMER_14_BIT = 14,
} ledc_timer_bit_t;

typedef enum {
    LEDC_AUTO_CLK = 0,
} ledc_clk_cfg_t;

typedef enum {
    LEDC_INTR_DISABLE = 0,
} ledc_intr_type_t;

typedef struct {
    ledc_mode_t speed_mode;
    ledc_timer_t timer_num;
    ledc_timer_bit_t duty_resolution;
    int freq_hz;
    ledc_clk_cfg_t clk_cfg;
} ledc_timer_config_t;

typedef struct {
    gpio_num_t gpio_num;
    ledc_mode_t speed_mode;
    ledc_channel_t channel;
    ledc_timer_t timer_sel;
    int duty;
    ledc_intr_type_t intr_type;
    int hpoint;
} ledc_channel_config_t;

// Mock ESP32 constants
#define ESP_INTR_FLAG_IRAM 0
#define ESP_ERR_INVALID_STATE 0x103

// Mock GPIO functions
esp_err_t gpio_config(const gpio_config_t* pGPIOConfig) { return ESP_OK; }
esp_err_t gpio_set_level(gpio_num_t gpio_num, uint32_t level) { return ESP_OK; }
int gpio_get_level(gpio_num_t gpio_num) { return 0; }
esp_err_t gpio_isr_handler_add(gpio_num_t gpio_num, void (*isr_handler)(void*), void* args) { return ESP_OK; }
esp_err_t gpio_install_isr_service(int intr_alloc_flags) { return ESP_OK; }

// Mock LEDC functions
esp_err_t ledc_timer_config(const ledc_timer_config_t* timer_conf) { return ESP_OK; }
esp_err_t ledc_channel_config(const ledc_channel_config_t* ledc_conf) { return ESP_OK; }
esp_err_t ledc_set_duty(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty) { return ESP_OK; }
esp_err_t ledc_update_duty(ledc_mode_t speed_mode, ledc_channel_t channel) { return ESP_OK; }

// Mock I2C types and functions
typedef enum {
    I2C_NUM_0 = 0,
    I2C_NUM_1 = 1,
    I2C_NUM_MAX = 2
} i2c_port_t;

typedef enum {
    I2C_MODE_MASTER = 0,
    I2C_MODE_SLAVE = 1,
} i2c_mode_t;

typedef struct {
    i2c_mode_t mode;
    int sda_io_num;
    int scl_io_num;
    gpio_pullup_t sda_pullup_en;
    gpio_pullup_t scl_pullup_en;
    struct {
        uint32_t clk_speed;
    } master;
    uint8_t slave_addr;
} i2c_config_t;

esp_err_t i2c_param_config(i2c_port_t i2c_num, const i2c_config_t* i2c_conf) { return ESP_OK; }
esp_err_t i2c_driver_install(i2c_port_t i2c_num, i2c_mode_t mode, int slv_rx_buf_len, int slv_tx_buf_len, int intr_alloc_flags) { return ESP_OK; }
esp_err_t i2c_master_write_read_device(i2c_port_t i2c_num, uint8_t device_address, const uint8_t* write_buffer, size_t write_size, uint8_t* read_buffer, size_t read_size, uint32_t ticks_to_wait) { return ESP_OK; }

// Additional I2C mocking for MPU6050
typedef struct i2c_cmd_desc_s* i2c_cmd_handle_t;
#define I2C_MASTER_WRITE 0
#define I2C_MASTER_READ 1
#define I2C_MASTER_ACK 0
#define I2C_MASTER_NACK 1

// Mock I2C command functions
i2c_cmd_handle_t i2c_cmd_link_create(void) { return (i2c_cmd_handle_t)1; }
void i2c_cmd_link_delete(i2c_cmd_handle_t cmd_handle) { (void)cmd_handle; }
esp_err_t i2c_master_start(i2c_cmd_handle_t cmd_handle) { return ESP_OK; }
esp_err_t i2c_master_stop(i2c_cmd_handle_t cmd_handle) { return ESP_OK; }
esp_err_t i2c_master_write_byte(i2c_cmd_handle_t cmd_handle, uint8_t data, bool ack_en) { return ESP_OK; }
esp_err_t i2c_master_read_byte(i2c_cmd_handle_t cmd_handle, uint8_t* data, int ack) { *data = 0x68; return ESP_OK; }
esp_err_t i2c_master_read(i2c_cmd_handle_t cmd_handle, uint8_t* data, size_t data_len, int ack) {
    // Provide some mock accelerometer data to avoid division by zero in angle calculations
    // This simulates a sensor reading of approximately 1g on Z-axis (upright position)
    if (data_len >= 14) {
        // Mock accelerometer data (16384 = 1g for ±2g range, big-endian format)
        data[0] = 0; data[1] = 0;           // accel_x = 0
        data[2] = 0; data[3] = 0;           // accel_y = 0
        data[4] = 0x40; data[5] = 0x00;     // accel_z = 16384 (1g) - high byte first
        data[6] = 0; data[7] = 0;           // temperature (skip)
        // Mock gyro data (all zeros)
        data[8] = 0; data[9] = 0;           // gyro_x = 0
        data[10] = 0; data[11] = 0;         // gyro_y = 0
        data[12] = 0; data[13] = 0;         // gyro_z = 0
    } else {
        for (size_t i = 0; i < data_len; i++) { data[i] = 0; }
    }
    return ESP_OK;
}
esp_err_t i2c_master_cmd_begin(i2c_port_t i2c_num, i2c_cmd_handle_t cmd_handle, uint32_t ticks_to_wait) { return ESP_OK; }

// Mock UART types and functions
typedef enum {
    UART_NUM_0 = 0,
    UART_NUM_1 = 1,
    UART_NUM_2 = 2,
    UART_NUM_MAX = 3
} uart_port_t;

typedef enum {
    UART_DATA_5_BITS = 0,
    UART_DATA_6_BITS = 1,
    UART_DATA_7_BITS = 2,
    UART_DATA_8_BITS = 3,
} uart_word_length_t;

typedef enum {
    UART_STOP_BITS_1 = 1,
    UART_STOP_BITS_2 = 2,
} uart_stop_bits_t;

typedef enum {
    UART_PARITY_DISABLE = 0,
    UART_PARITY_EVEN = 2,
    UART_PARITY_ODD = 3,
} uart_parity_t;

typedef enum {
    UART_HW_FLOWCTRL_DISABLE = 0,
    UART_HW_FLOWCTRL_RTS = 1,
    UART_HW_FLOWCTRL_CTS = 2,
    UART_HW_FLOWCTRL_CTS_RTS = 3,
} uart_hw_flowctrl_t;

typedef enum {
    UART_SCLK_DEFAULT = 0,
} uart_sclk_t;

#define UART_PIN_NO_CHANGE -1

typedef struct {
    int baud_rate;
    uart_word_length_t data_bits;
    uart_parity_t parity;
    uart_stop_bits_t stop_bits;
    uart_hw_flowctrl_t flow_ctrl;
    uint8_t rx_flow_ctrl_thresh;
    uart_sclk_t source_clk;
} uart_config_t;

esp_err_t uart_param_config(uart_port_t uart_num, const uart_config_t* uart_config) { return ESP_OK; }
esp_err_t uart_set_pin(uart_port_t uart_num, int tx_io_num, int rx_io_num, int rts_io_num, int cts_io_num) { return ESP_OK; }
esp_err_t uart_driver_install(uart_port_t uart_num, int rx_buffer_size, int tx_buffer_size, int queue_size, void* uart_queue, int intr_alloc_flags) { return ESP_OK; }
int uart_read_bytes(uart_port_t uart_num, uint8_t* buf, uint32_t length, uint32_t ticks_to_wait) { return 0; }
int uart_write_bytes(uart_port_t uart_num, const char* src, size_t size) { return size; }

// Mock IRAM_ATTR and constants
#define IRAM_ATTR

// Math constants
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#endif

// Include source files directly for testing
#include "../src/logic/kalman_filter.c"
#include "../src/logic/pid_controller.c"
#include "../src/output/ble_controller.c"
#include "../src/input/encoder_sensor.c"
#include "../src/output/motor_control.c"
#include "../src/bsw/pwm_driver.c"
#include "../src/input/imu_sensor.c"
#include "../src/bsw/i2c_driver.c"
#include "../src/input/gps_sensor.c"
#include "../src/bsw/uart_driver.c"
#include "../src/output/servo_standup.c"

void setUp(void) {
    // Set up code here, if needed
}

void tearDown(void) {
    // Clean up code here, if needed
}

// Kalman Filter Tests
void test_kalman_filter_init(void) {
    kalman_filter_t filter;
    kalman_filter_init(&filter);

    // Test initial values - these are set by the init function internally
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, filter.angle);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, filter.bias);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, filter.rate);
}

void test_kalman_filter_update(void) {
    kalman_filter_t filter;
    kalman_filter_init(&filter);

    // Set filter parameters
    kalman_filter_set_qangle(&filter, 0.001f);
    kalman_filter_set_qbias(&filter, 0.003f);
    kalman_filter_set_rmeasure(&filter, 0.03f);

    // Test first update
    float result = kalman_filter_get_angle(&filter, 5.0f, 0.0f, 0.01f);
    TEST_ASSERT_TRUE(result >= 0.0f);
    TEST_ASSERT_TRUE(result <= 10.0f);

    // Test convergence with multiple updates
    for (int i = 0; i < 10; i++) {
        result = kalman_filter_get_angle(&filter, 5.0f, 0.0f, 0.01f);
    }
    // Kalman filter should converge towards the measurement
    TEST_ASSERT_TRUE(result > 0.0f);
    TEST_ASSERT_TRUE(result < 10.0f);
}

// PID Controller Tests
void test_pid_controller_init(void) {
    pid_controller_t pid;
    pid_controller_init(&pid, 1.0f, 0.1f, 0.01f);
    pid_controller_set_output_limits(&pid, -100.0f, 100.0f);

    TEST_ASSERT_FLOAT_WITHIN(0.001f, 1.0f, pid.kp);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.1f, pid.ki);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.01f, pid.kd);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, -100.0f, pid.output_min);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 100.0f, pid.output_max);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, pid.integral);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, pid.previous_error);
    TEST_ASSERT_TRUE(pid.first_run);
}

void test_pid_controller_proportional(void) {
    pid_controller_t pid;
    pid_controller_init(&pid, 1.0f, 0.0f, 0.0f);  // Only P term
    pid_controller_set_output_limits(&pid, -100.0f, 100.0f);
    pid_controller_set_setpoint(&pid, 10.0f);

    // First call returns 0 due to first_run flag
    float output1 = pid_controller_compute(&pid, 5.0f);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, output1);

    // Second call should return proper proportional response
    float output2 = pid_controller_compute(&pid, 5.0f);
    TEST_ASSERT_FLOAT_WITHIN(0.1f, 5.0f, output2);  // Error = 10-5 = 5, Output = 1.0 * 5 = 5
}

void test_pid_controller_output_limits(void) {
    pid_controller_t pid;
    pid_controller_init(&pid, 10.0f, 0.0f, 0.0f);  // High gain
    pid_controller_set_output_limits(&pid, -5.0f, 5.0f);

    // Test upper limit - skip first run
    pid_controller_set_setpoint(&pid, 10.0f);
    pid_controller_compute(&pid, 0.0f);  // First run returns 0
    float output_high = pid_controller_compute(&pid, 0.0f);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 5.0f, output_high);

    // Reset and test lower limit
    pid_controller_reset(&pid);
    pid_controller_set_setpoint(&pid, 0.0f);
    pid_controller_compute(&pid, 10.0f);  // First run returns 0
    float output_low = pid_controller_compute(&pid, 10.0f);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, -5.0f, output_low);
}

void test_pid_controller_reset(void) {
    pid_controller_t pid;
    pid_controller_init(&pid, 1.0f, 1.0f, 1.0f);
    pid_controller_set_output_limits(&pid, -100.0f, 100.0f);
    pid_controller_set_setpoint(&pid, 10.0f);

    // Run some updates to build up integral and previous error
    pid_controller_compute(&pid, 5.0f);
    pid_controller_compute(&pid, 6.0f);

    // Reset and check
    pid_controller_reset(&pid);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, pid.integral);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, pid.previous_error);
    TEST_ASSERT_TRUE(pid.first_run);
}

// BLE Controller Tests
void test_ble_controller_init(void) {
    ble_controller_t ble;
    esp_err_t result = ble_controller_init(&ble, "TestBot");

    TEST_ASSERT_EQUAL(ESP_OK, result);
    TEST_ASSERT_FALSE(ble.device_connected);
    TEST_ASSERT_EQUAL(0, ble.current_command.direction);
    TEST_ASSERT_EQUAL(0, ble.current_command.turn);
    TEST_ASSERT_EQUAL(0, ble.current_command.speed);
    TEST_ASSERT_TRUE(ble.current_command.balance);
    TEST_ASSERT_FALSE(ble.current_command.standup);
}

void test_ble_controller_parse_command(void) {
    ble_controller_t ble;
    ble_controller_init(&ble, "TestBot");

    // Test move command
    ble_controller_parse_command(&ble, "MOVE:1,50,75");
    TEST_ASSERT_EQUAL(1, ble.current_command.direction);
    TEST_ASSERT_EQUAL(50, ble.current_command.turn);
    TEST_ASSERT_EQUAL(75, ble.current_command.speed);

    // Test balance command
    ble_controller_parse_command(&ble, "BALANCE_OFF");
    TEST_ASSERT_FALSE(ble.current_command.balance);

    ble_controller_parse_command(&ble, "BALANCE_ON");
    TEST_ASSERT_TRUE(ble.current_command.balance);

    // Test standup command
    ble_controller_parse_command(&ble, "STANDUP");
    TEST_ASSERT_TRUE(ble.current_command.standup);
}

void test_ble_controller_get_command(void) {
    ble_controller_t ble;
    ble_controller_init(&ble, "TestBot");

    // Set some command values
    ble.current_command.direction = -1;
    ble.current_command.turn = -25;
    ble.current_command.speed = 60;
    ble.current_command.balance = false;

    remote_command_t cmd = ble_controller_get_command(&ble);
    TEST_ASSERT_EQUAL(-1, cmd.direction);
    TEST_ASSERT_EQUAL(-25, cmd.turn);
    TEST_ASSERT_EQUAL(60, cmd.speed);
    TEST_ASSERT_FALSE(cmd.balance);
}

void test_ble_controller_connection_status(void) {
    ble_controller_t ble;
    ble_controller_init(&ble, "TestBot");

    // Initially not connected
    TEST_ASSERT_FALSE(ble_controller_is_connected(&ble));

    // Manually set connection status for testing
    ble.device_connected = true;
    TEST_ASSERT_TRUE(ble_controller_is_connected(&ble));

    // Test status sending when connected
    esp_err_t result = ble_controller_send_status(&ble, "Test Status");
    TEST_ASSERT_EQUAL(ESP_OK, result);

    // Test status sending when disconnected
    ble.device_connected = false;
    result = ble_controller_send_status(&ble, "Test Status");
    TEST_ASSERT_EQUAL(ESP_FAIL, result);
}

// Motor Encoder Tests
void test_motor_encoder_init(void) {
    motor_encoder_t motor;
    esp_err_t result = motor_encoder_init(&motor,
                                         GPIO_NUM_2, GPIO_NUM_3,  // encoder pins
                                         GPIO_NUM_4, GPIO_NUM_5,  // motor pins
                                         GPIO_NUM_1, LEDC_CHANNEL_0,  // enable pin/channel
                                         1000, 6.5);  // PPR and wheel diameter

    TEST_ASSERT_EQUAL(ESP_OK, result);
    TEST_ASSERT_EQUAL(GPIO_NUM_2, motor.encoder_pin_a);
    TEST_ASSERT_EQUAL(GPIO_NUM_3, motor.encoder_pin_b);
    TEST_ASSERT_EQUAL(GPIO_NUM_4, motor.motor_pin_a);
    TEST_ASSERT_EQUAL(GPIO_NUM_5, motor.motor_pin_b);
    TEST_ASSERT_EQUAL(GPIO_NUM_1, motor.enable_pin);
    TEST_ASSERT_EQUAL(LEDC_CHANNEL_0, motor.enable_channel);
    TEST_ASSERT_EQUAL(1000, motor.ppr);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 6.5f, motor.wheel_diameter);
    TEST_ASSERT_EQUAL(0, motor.encoder_count);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, motor.current_speed);
}

void test_motor_encoder_position_distance(void) {
    motor_encoder_t motor;
    motor_encoder_init(&motor, GPIO_NUM_2, GPIO_NUM_3, GPIO_NUM_4, GPIO_NUM_5,
                      GPIO_NUM_1, LEDC_CHANNEL_0, 1000, 6.5);

    // Simulate encoder counts
    motor.encoder_count = 500;  // Half revolution

    int32_t position = motor_encoder_get_position(&motor);
    TEST_ASSERT_EQUAL(500, position);

    float distance = motor_encoder_get_distance(&motor);
    float expected_distance = (500.0f / 1000.0f) * M_PI * 6.5f;  // (count/PPR) * π * diameter
    TEST_ASSERT_FLOAT_WITHIN(0.1f, expected_distance, distance);

    // Test reset
    motor_encoder_reset_position(&motor);
    TEST_ASSERT_EQUAL(0, motor_encoder_get_position(&motor));
}

void test_motor_encoder_speed_calculation(void) {
    motor_encoder_t motor;
    motor_encoder_init(&motor, GPIO_NUM_2, GPIO_NUM_3, GPIO_NUM_4, GPIO_NUM_5,
                      GPIO_NUM_1, LEDC_CHANNEL_0, 1000, 6.5);

    // Simulate time progression and encoder movement
    motor.last_time = 1000;  // 1 second ago (in ms)
    motor.last_position = 0;
    motor.encoder_count = 1000;  // 1 full revolution

    // Mock current time to be 2000ms (1 second later)
    // This would normally be done by the system timer
    motor_encoder_update_speed(&motor);

    float speed = motor_encoder_get_speed(&motor);
    // Speed should be positive (we moved forward)
    TEST_ASSERT_TRUE(speed >= 0.0f);
}

void test_motor_encoder_speed_control(void) {
    motor_encoder_t motor;
    motor_encoder_init(&motor, GPIO_NUM_2, GPIO_NUM_3, GPIO_NUM_4, GPIO_NUM_5,
                      GPIO_NUM_1, LEDC_CHANNEL_0, 1000, 6.5);

    // Test forward speed
    motor_encoder_set_speed(&motor, 50);
    // In a real system, this would set PWM duty cycle
    // For testing, we just verify the function doesn't crash

    // Test reverse speed
    motor_encoder_set_speed(&motor, -50);

    // Test stop
    motor_encoder_stop(&motor);

    // These are mostly integration tests since the actual hardware behavior is mocked
    TEST_ASSERT_TRUE(true);  // If we get here without crashing, the functions work
}

// MPU6050 Sensor Tests
void test_mpu6050_sensor_init(void) {
    mpu6050_sensor_t sensor;
    esp_err_t result = mpu6050_sensor_init(&sensor, I2C_NUM_0, 21, 22);

    TEST_ASSERT_EQUAL(ESP_OK, result);
    TEST_ASSERT_EQUAL(I2C_NUM_0, sensor.i2c_port);
    TEST_ASSERT_TRUE(mpu6050_sensor_is_ready(&sensor));
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, sensor.data.accel_x);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, sensor.data.accel_y);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, sensor.data.accel_z);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, sensor.data.gyro_x);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, sensor.data.gyro_y);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, sensor.data.gyro_z);
}

void test_mpu6050_sensor_update(void) {
    mpu6050_sensor_t sensor;
    mpu6050_sensor_init(&sensor, I2C_NUM_0, 21, 22);

    esp_err_t result = mpu6050_sensor_update(&sensor);
    TEST_ASSERT_EQUAL(ESP_OK, result);

    // Since we're using mock data (all zeros), angles should be near zero
    float pitch = mpu6050_sensor_get_pitch(&sensor);
    float roll = mpu6050_sensor_get_roll(&sensor);

    TEST_ASSERT_TRUE(pitch >= -90.0f && pitch <= 90.0f);
    TEST_ASSERT_TRUE(roll >= -180.0f && roll <= 180.0f);
}

void test_mpu6050_sensor_getters(void) {
    mpu6050_sensor_t sensor;
    mpu6050_sensor_init(&sensor, I2C_NUM_0, 21, 22);
    mpu6050_sensor_update(&sensor);

    // Test all getter functions - just verify they return reasonable values
    float accel_x = mpu6050_sensor_get_accel_x(&sensor);
    float accel_y = mpu6050_sensor_get_accel_y(&sensor);
    float accel_z = mpu6050_sensor_get_accel_z(&sensor);
    float gyro_x = mpu6050_sensor_get_gyro_x(&sensor);
    float gyro_y = mpu6050_sensor_get_gyro_y(&sensor);
    float gyro_z = mpu6050_sensor_get_gyro_z(&sensor);

    // Verify values are in reasonable ranges (±4g for accel, ±250°/s for gyro)
    TEST_ASSERT_TRUE(accel_x >= -4.0f && accel_x <= 4.0f);
    TEST_ASSERT_TRUE(accel_y >= -4.0f && accel_y <= 4.0f);
    TEST_ASSERT_TRUE(accel_z >= -4.0f && accel_z <= 4.0f);
    TEST_ASSERT_TRUE(gyro_x >= -250.0f && gyro_x <= 250.0f);
    TEST_ASSERT_TRUE(gyro_y >= -250.0f && gyro_y <= 250.0f);
    TEST_ASSERT_TRUE(gyro_z >= -250.0f && gyro_z <= 250.0f);

    // Test calculated angles (should be near 0 with our mock data)
    float pitch = mpu6050_sensor_get_pitch(&sensor);
    float roll = mpu6050_sensor_get_roll(&sensor);
    TEST_ASSERT_FLOAT_WITHIN(5.0f, 0.0f, pitch);  // Allow 5 degree tolerance
    TEST_ASSERT_FLOAT_WITHIN(5.0f, 0.0f, roll);   // Allow 5 degree tolerance
}

// GPS Module Tests
void test_gps_module_init(void) {
    gps_module_t gps;
    esp_err_t result = gps_module_init(&gps, UART_NUM_1, 17, 16, 9600);

    TEST_ASSERT_EQUAL(ESP_OK, result);
    TEST_ASSERT_EQUAL(UART_NUM_1, gps.uart_port);
    TEST_ASSERT_FALSE(gps_module_is_valid(&gps));
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, gps.data.latitude);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, gps.data.longitude);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, gps.data.altitude);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, gps.data.speed);
    TEST_ASSERT_EQUAL(0, gps.data.satellites);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, gps.data.hdop);
}

void test_gps_module_getters(void) {
    gps_module_t gps;
    gps_module_init(&gps, UART_NUM_1, 17, 16, 9600);

    // Test getter functions with initial values
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, gps_module_get_latitude(&gps));
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, gps_module_get_longitude(&gps));
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, gps_module_get_altitude(&gps));
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, gps_module_get_speed(&gps));
    TEST_ASSERT_EQUAL(0, gps_module_get_satellites(&gps));

    // Test get_data function
    gps_data_t data = gps_module_get_data(&gps);
    TEST_ASSERT_FALSE(data.valid);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, data.latitude);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, data.longitude);
}

void test_gps_module_update(void) {
    gps_module_t gps;
    gps_module_init(&gps, UART_NUM_1, 17, 16, 9600);

    // Since we mock uart_read_bytes to return 0, update should not crash
    gps_module_update(&gps);

    // GPS should still be invalid after update with no data
    TEST_ASSERT_FALSE(gps_module_is_valid(&gps));

    // Test that buffer is properly initialized
    TEST_ASSERT_EQUAL(0, gps.buffer_index);
}

// Servo Standup Tests
void test_servo_standup_init(void) {
    servo_standup_t servo;
    esp_err_t result = servo_standup_init(&servo, GPIO_NUM_18, LEDC_CHANNEL_1, 90, 0);

    TEST_ASSERT_EQUAL(ESP_OK, result);
    TEST_ASSERT_EQUAL(GPIO_NUM_18, servo.servo_pin);
    TEST_ASSERT_EQUAL(LEDC_CHANNEL_1, servo.servo_channel);
    TEST_ASSERT_EQUAL(90, servo.extended_angle);
    TEST_ASSERT_EQUAL(0, servo.retracted_angle);
    TEST_ASSERT_EQUAL(0, servo.current_angle);
    TEST_ASSERT_EQUAL(STANDUP_IDLE, servo.state);
    TEST_ASSERT_FALSE(servo.standup_requested);
    TEST_ASSERT_FALSE(servo.standup_in_progress);
}

void test_servo_standup_request_and_state(void) {
    servo_standup_t servo;
    servo_standup_init(&servo, GPIO_NUM_18, LEDC_CHANNEL_1, 90, 0);

    // Test initial state
    TEST_ASSERT_FALSE(servo_standup_is_standing_up(&servo));
    TEST_ASSERT_FALSE(servo_standup_is_complete(&servo));
    TEST_ASSERT_EQUAL(STANDUP_IDLE, servo_standup_get_state(&servo));

    // Request standup
    servo_standup_request_standup(&servo);
    TEST_ASSERT_TRUE(servo.standup_requested);

    // Update should start the standup sequence
    servo_standup_update(&servo);
    TEST_ASSERT_TRUE(servo_standup_is_standing_up(&servo));
    TEST_ASSERT_EQUAL(STANDUP_EXTENDING, servo_standup_get_state(&servo));
}

void test_servo_standup_reset(void) {
    servo_standup_t servo;
    servo_standup_init(&servo, GPIO_NUM_18, LEDC_CHANNEL_1, 90, 0);

    // Start a standup sequence
    servo_standup_request_standup(&servo);
    servo_standup_update(&servo);
    TEST_ASSERT_TRUE(servo_standup_is_standing_up(&servo));

    // Reset should stop the sequence
    servo_standup_reset(&servo);
    TEST_ASSERT_FALSE(servo_standup_is_standing_up(&servo));
    TEST_ASSERT_EQUAL(STANDUP_IDLE, servo_standup_get_state(&servo));
    TEST_ASSERT_FALSE(servo.standup_requested);
}

void test_servo_standup_set_parameters(void) {
    servo_standup_t servo;
    servo_standup_init(&servo, GPIO_NUM_18, LEDC_CHANNEL_1, 90, 0);

    // Test setting timings
    servo_standup_set_timings(&servo, 500, 1500, 800);
    TEST_ASSERT_EQUAL(500, servo.extend_duration);
    TEST_ASSERT_EQUAL(1500, servo.push_duration);
    TEST_ASSERT_EQUAL(800, servo.retract_duration);

    // Test setting angles
    servo_standup_set_angles(&servo, 120, 10);
    TEST_ASSERT_EQUAL(120, servo.extended_angle);
    TEST_ASSERT_EQUAL(10, servo.retracted_angle);
}

int main(void) {
    printf("Running BalanceBot Native Tests\n");
    printf("================================\n\n");

    UNITY_BEGIN();

    printf("Running Kalman Filter Tests...\n");
    RUN_TEST(test_kalman_filter_init);
    RUN_TEST(test_kalman_filter_update);

    printf("\nRunning PID Controller Tests...\n");
    RUN_TEST(test_pid_controller_init);
    RUN_TEST(test_pid_controller_proportional);
    RUN_TEST(test_pid_controller_output_limits);
    RUN_TEST(test_pid_controller_reset);

    printf("\nRunning BLE Controller Tests...\n");
    RUN_TEST(test_ble_controller_init);
    RUN_TEST(test_ble_controller_parse_command);
    RUN_TEST(test_ble_controller_get_command);
    RUN_TEST(test_ble_controller_connection_status);

    printf("\nRunning Motor Encoder Tests...\n");
    RUN_TEST(test_motor_encoder_init);
    RUN_TEST(test_motor_encoder_position_distance);
    RUN_TEST(test_motor_encoder_speed_calculation);
    RUN_TEST(test_motor_encoder_speed_control);

    printf("\nRunning MPU6050 Sensor Tests...\n");
    RUN_TEST(test_mpu6050_sensor_init);
    RUN_TEST(test_mpu6050_sensor_update);
    RUN_TEST(test_mpu6050_sensor_getters);

    printf("\nRunning GPS Module Tests...\n");
    RUN_TEST(test_gps_module_init);
    RUN_TEST(test_gps_module_getters);
    RUN_TEST(test_gps_module_update);

    printf("\nRunning Servo Standup Tests...\n");
    RUN_TEST(test_servo_standup_init);
    RUN_TEST(test_servo_standup_request_and_state);
    RUN_TEST(test_servo_standup_reset);
    RUN_TEST(test_servo_standup_set_parameters);

    int result = UNITY_END();

    if (result == 0) {
        printf("\n✓ All tests passed!\n");
    } else {
        printf("\n✗ Some tests failed. Check output above.\n");
    }

    return result;
}